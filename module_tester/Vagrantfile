require 'getoptlong'
# ruby -w Vagrantfile

# Which devices do we know about?
# - and check for their driver on the hosting host
# ioTypes = {
#
# }

def checkIoModule()
  ioModule=`lsmod | grep iomemory`
  if ioModule != ""
    return ioModule
  end
  return false
end

##
# Check for io devices that we care about
##
def findBusIoDevices()
  busDeviceMap={}
  mString=' SanDisk'
  # rString='Mass storage controller [0180]: '
  # 05:00.0 Mass storage controller [0180]: SanDisk ioDimm3 [1aed:1005] (rev 01)
  # 06:00.0 Mass storage controller [0180]: SanDisk ioDimm3 [1aed:1005] (rev 01)
  # 08:00.0 Mass storage controller [0180]: SanDisk ioMemory HHHL [1aed:3002]
  ioDevices=`lspci -nn | grep #{mString}`.split(/\n+/)
  if ioDevices != ""
    for line in ioDevices
      # somehow the first character in bust is "", so we move some things around
      bust=line.split(/(\d{2}):([\d\.]+) ([\w\s]+) (\[\d+\]): ([\w\d\s]+) \[([\w\d]+):([\w\d]+)\]\s?(\(rev (\d+)?)?/)
      busDeviceMap[bust[1]] = {
        :pciId => "#{bust[1]}:#{bust[2]}",
        :pciBusId => "#{bust[1]}",
        :pciSubId => "#{bust[2]}",
        :category => "#{bust[3]}",
        :categoryId => "#{bust[4]}",
        :deviceName => "#{bust[5]}",
        :vendorId => "#{bust[6]}",
        :deviceId => "#{bust[7]}",
        :revision => "#{bust[9]}"
      }
    end
    return busDeviceMap
  end
  return false
end

##
# Validate the devices that can be used
##
def checkValidDevices(pciBusIds)
  ioDeviceMap=findBusIoDevices
  if pciBusIds != ""
    for ios in pciBusIds.split(/,/)
      if ioDeviceMap[ios]
        map=ioDeviceMap[ios]
        puts("Valid device on PCI bus #{ios}: #{map[:pciId]}, #{map[:deviceName]}, #{map[:vendorId]}:#{map[:deviceId]} ")
      else
        deviceListUsage
        abort("Device on PCI bus #{ios} is not a valid device")
      end
    end
  end
end

##
# Give back usage based on devices that exist
##
def deviceListUsage()
  ioDeviceMap=findBusIoDevices
  if ioDeviceMap != ""
    keys=[]
    ioDeviceMap.each_key do |key|
      keys.push(key)
      map=ioDeviceMap[key]
      puts("pcibusid: #{key} - device: #{map[:deviceName]} [#{map[:vendorId]}:#{map[:deviceId]}]")
    end
    line="#{keys.shift}"
    if keys.length != 0
      line = line + ",(" + keys.join(",") + ")"
    end
    puts("Usage: vagrant --pcibusid=#{line} <command>")
  else
    puts("No Sandisk Mass Storage Controller Found to pass through, aborting")
  end
end

opts = GetoptLong.new(
  [ '--pcibusid', GetoptLong::OPTIONAL_ARGUMENT ],
  [ '--box', GetoptLong::OPTIONAL_ARGUMENT ],
  [ '--force', GetoptLong::OPTIONAL_ARGUMENT ],
  [ '--break-provisioning', GetoptLong::OPTIONAL_ARGUMENT ],
  [ '--provision', GetoptLong::OPTIONAL_ARGUMENT ],
  [ '--debug', GetoptLong::OPTIONAL_ARGUMENT ]
)

# "archlinux/archlinux"
# "suse/something???"
boxParam='generic/debian10'
haltProvisioning=false
skipSelection=true
pciBusIds=''

for arg in ARGV
  case arg
  when 'up'
      skipSelection=false
  end
end

opts.each do |opt, arg|
  case opt
  when '--box'
    boxParam=arg
  when '--break-provisioning'
    haltProvisioning=true
  when '--pcibusid'
    pciBusIds=arg
  end
end

if pciBusIds == "" && skipSelection == false
  deviceListUsage
  exit(1)
elsif pciBusIds != ""
  checkValidDevices(pciBusIds)
end

if checkIoModule
  abort("There seems to be an iomemory module loaded: #{checkIoModule}, aborting")
# else
#  abort("testing!")
end

cpus = 8
memory = 8192
# box = "generic/ubuntu1904"
# box = "generic/debian10"
# box = "generic/opensuse15
box = "#{boxParam}"
hostname = "fio.local"

$proxy = <<-SHELL
  proxy=#{ENV['APT_PROXY']}
  if [ "$proxy" != "" ]; then
    echo "Acquire::http::Proxy \\\"$proxy\\\";" > /etc/apt/apt.conf.d/01proxy
  fi
SHELL

$resolvFix = <<-SHELL
  echo "DNS=192.168.86.1" >> /etc/systemd/resolved.conf
  systemctl daemon-reload
  systemctl restart systemd-resolved
SHELL

Vagrant.configure("2") do |config|
  config.vm.box = box
  config.vm.host_name = hostname

  config.vm.provider :libvirt do |lv, override|
    lv.cpus = cpus
    lv.memory = memory
    # Support for more dynamic things...
    for ios in pciBusIds.split(/,/)
       lv.pci :bus => "0x#{ios}", :slot => '0x00', :function => '0x0'
    end
    # lv.pci :bus => '0x06', :slot => '0x00', :function => '0x0'
    if #{box}.match(/suse/i)
      lv.disk_bus = "sata"
    end
    if #{box}.match(/archlinux/i)
      lv.disk_bus = "virtio"
      config.vm.provision "shell", inline: $resolvFix, privileged: true
      # puts "With arch you have to run 'vagrant provision' after failure"
    end
    if #{box}.match(/debian/i) or #{box}.match(/ubuntu/)
      config.vm.provision "shell", inline: $proxy, privileged: true
    end
  end
  config.vm.provision "file", source: "../envfile", destination: "envfile"
  config.vm.provision "shell", path: "scripts/prep_host.sh"
  config.vm.provision :reload
  if not haltProvisioning
      config.vm.provision "shell", path: "scripts/setup_module.sh"
      config.vm.provision "shell", path: "scripts/build_package.sh"
      # test package install?
      config.vm.provision "shell", path: "scripts/install_fio_tools.sh"
      config.vm.provision "shell", path: "scripts/setup_filesystem.sh"
      config.vm.provision "shell", path: "scripts/test_tgz.sh"
      config.vm.provision "shell", path: "scripts/test_page_cache.sh"
      config.vm.provision "shell", path: "scripts/test_fio.sh"
      config.vm.provision "shell", path: "scripts/remove_module.sh"
      config.vm.provision "shell", path: "scripts/scrape_errors.sh"
  end
end
